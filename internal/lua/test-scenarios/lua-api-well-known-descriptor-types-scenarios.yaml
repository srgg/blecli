test_cases:
# GOAL: Verify that well-known BLE descriptor values and parsed values are correctly exposed in Lua API
#
# TEST SCENARIO: Create characteristics with various standard BLE descriptor types → verify raw values and parsed structures

# ===================================================================
# POSITIVE TESTS: Well-Known Descriptors (9 tests)
# ===================================================================

# --- Client Characteristic Configuration (0x2902) ---

  - name: "CCCD: Notifications Enabled"
    # GOAL: Verify CCCD with notifications enabled is correctly parsed
    #
    # TEST SCENARIO: CCCD with value 0x0100 (notifications=true, indications=false) → verify parsed_value structure
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2902" then
        error("Expected CCCD (0x2902), got: " .. desc.uuid)
      end
      if desc.name ~= "Client Characteristic Configuration" then
        error("Expected CCCD name, got: " .. (desc.name or "nil"))
      end
      if desc.value ~= "0100" then
        error("Expected value 0100, got: " .. (desc.value or "nil"))
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if desc.parsed_value.notifications ~= true then
        error("Expected notifications=true")
      end
      if desc.parsed_value.indications ~= false then
        error("Expected indications=false")
      end
      print("CCCD notifications test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01, 0x00]  # Notifications enabled
    expected_stdout: |
      CCCD notifications test passed

  - name: "CCCD: Indications Enabled"
    # GOAL: Verify CCCD with indications enabled is correctly parsed
    #
    # TEST SCENARIO: CCCD with value 0x0200 (notifications=false, indications=true) → verify parsed_value structure
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.value ~= "0200" then
        error("Expected value 0200, got: " .. (desc.value or "nil"))
      end
      if desc.parsed_value.notifications ~= false then
        error("Expected notifications=false")
      end
      if desc.parsed_value.indications ~= true then
        error("Expected indications=true")
      end
      print("CCCD indications test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x02, 0x00]  # Indications enabled
    expected_stdout: |
      CCCD indications test passed

  - name: "CCCD: Both Notifications and Indications Enabled"
    # GOAL: Verify CCCD with both notifications and indications enabled
    #
    # TEST SCENARIO: CCCD with value 0x0300 → verify both flags are true
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.value ~= "0300" then
        error("Expected value 0300, got: " .. (desc.value or "nil"))
      end
      if desc.parsed_value.notifications ~= true then
        error("Expected notifications=true")
      end
      if desc.parsed_value.indications ~= true then
        error("Expected indications=true")
      end
      print("CCCD both enabled test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x03, 0x00]  # Both enabled
    expected_stdout: |
      CCCD both enabled test passed

# --- User Description (0x2901) ---

  - name: "User Description: ASCII String"
    # GOAL: Verify User Description descriptor is correctly parsed as UTF-8 string
    #
    # TEST SCENARIO: User Description with "Hello" → verify parsed_value is string
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2901" then
        error("Expected User Description (0x2901), got: " .. desc.uuid)
      end
      if desc.name ~= "Characteristic User Descriptor" then
        error("Expected User Description name")
      end
      if desc.value ~= "48656C6C6F" then
        error("Expected value 48656C6C6F (Hello), got: " .. (desc.value or "nil"))
      end
      if desc.parsed_value ~= "Hello" then
        error("Expected parsed_value='Hello', got: " .. (desc.parsed_value or "nil"))
      end
      print("User Description test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2901"
                value: [0x48, 0x65, 0x6C, 0x6C, 0x6F]  # "Hello" in ASCII
    expected_stdout: |
      User Description test passed

# --- Extended Properties (0x2900) ---

  - name: "Extended Properties: Reliable Write and Writable Auxiliaries"
    # GOAL: Verify Extended Properties descriptor is correctly parsed
    #
    # TEST SCENARIO: Extended Properties with reliable_write + writable_auxiliaries → verify boolean flags
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2900" then
        error("Expected Extended Properties (0x2900), got: " .. desc.uuid)
      end
      if desc.name ~= "Characteristic Extended Properties" then
        error("Expected Extended Properties name")
      end
      if desc.value ~= "0300" then
        error("Expected value 0300, got: " .. (desc.value or "nil"))
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if desc.parsed_value.reliable_write ~= true then
        error("Expected reliable_write=true")
      end
      if desc.parsed_value.writable_auxiliaries ~= true then
        error("Expected writable_auxiliaries=true")
      end
      print("Extended Properties test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2900"
                value: [0x03, 0x00]  # Reliable Write + Writable Auxiliaries
    expected_stdout: |
      Extended Properties test passed

# --- Presentation Format (0x2904) ---

  - name: "Presentation Format: Battery Level Percentage"
    # GOAL: Verify Presentation Format descriptor is correctly parsed
    #
    # TEST SCENARIO: Presentation Format for battery percentage → verify all fields
    script: |
      local char = blim.characteristic("180f", "2a19")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2904" then
        error("Expected Presentation Format (0x2904), got: " .. desc.uuid)
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if desc.parsed_value.format ~= 4 then
        error("Expected format=4 (uint8), got: " .. tostring(desc.parsed_value.format))
      end
      if desc.parsed_value.exponent ~= 0 then
        error("Expected exponent=0, got: " .. tostring(desc.parsed_value.exponent))
      end
      if desc.parsed_value.unit ~= 10497 then
        error("Expected unit=10497 (percentage 0x2901), got: " .. tostring(desc.parsed_value.unit))
      end
      if desc.parsed_value.namespace ~= 1 then
        error("Expected namespace=1 (Bluetooth SIG), got: " .. tostring(desc.parsed_value.namespace))
      end
      print("Presentation Format test passed")
    peripheral:
      - service: "180f"
        characteristics:
          - uuid: "2a19"
            descriptors:
              - uuid: "2904"
                value: [0x04, 0x00, 0x01, 0x29, 0x01, 0x00, 0x00]  # uint8, exponent=0, unit=0x2901 (percentage)
    expected_stdout: |
      Presentation Format test passed

# --- Server Configuration (0x2903) ---

  - name: "Server Config: Broadcasts Enabled"
    # GOAL: Verify Server Characteristic Configuration descriptor is correctly parsed
    #
    # TEST SCENARIO: Server Config with broadcasts enabled → verify boolean flag
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2903" then
        error("Expected Server Config (0x2903), got: " .. desc.uuid)
      end
      if desc.value ~= "0100" then
        error("Expected value 0100, got: " .. (desc.value or "nil"))
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if desc.parsed_value.broadcasts ~= true then
        error("Expected broadcasts=true")
      end
      print("Server Config test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2903"
                value: [0x01, 0x00]  # Broadcasts enabled
    expected_stdout: |
      Server Config test passed

# --- Valid Range (0x2906) ---

  - name: "Valid Range: Min and Max Values"
    # GOAL: Verify Valid Range descriptor is correctly parsed
    #
    # TEST SCENARIO: Valid Range with min=0x0000, max=0x00FF → verify hex strings
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2906" then
        error("Expected Valid Range (0x2906), got: " .. desc.uuid)
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if desc.parsed_value.min ~= "0000" then
        error("Expected min=0000, got: " .. (desc.parsed_value.min or "nil"))
      end
      if desc.parsed_value.max ~= "00FF" then
        error("Expected max=00FF, got: " .. (desc.parsed_value.max or "nil"))
      end
      print("Valid Range test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2906"
                value: [0x00, 0x00, 0x00, 0xFF]  # min=0x0000, max=0x00FF
    expected_stdout: |
      Valid Range test passed

# --- Unknown Descriptors ---

  - name: "Unknown Descriptor: Custom UUID Returns Raw Bytes"
    # GOAL: Verify unknown descriptor UUIDs return raw byte values
    #
    # TEST SCENARIO: Custom descriptor UUID → verify value is hex string, parsed_value is also hex string
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "ff01" then
        error("Expected custom UUID (0xFF01), got: " .. desc.uuid)
      end
      if desc.value ~= "DEADBEEF" then
        error("Expected value DEADBEEF, got: " .. (desc.value or "nil"))
      end
      if desc.parsed_value ~= "DEADBEEF" then
        error("Expected parsed_value=DEADBEEF (raw bytes), got: " .. (desc.parsed_value or "nil"))
      end
      print("Unknown descriptor test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "ff01"
                value: [0xDE, 0xAD, 0xBE, 0xEF]  # Custom data
    expected_stdout: |
      Unknown descriptor test passed

# ===================================================================
# ERROR HANDLING TESTS (6 tests)
# ===================================================================

# --- Parse Errors ---

  - name: "Error: Parse Error in CCCD (Invalid Length)"
    # GOAL: Verify that parse errors are correctly represented in parsed_value
    #
    # TEST SCENARIO: CCCD with invalid length (1 byte instead of 2) → verify parsed_value contains error
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2902" then
        error("Expected CCCD (0x2902)")
      end
      if desc.value ~= "01" then
        error("Expected value 01, got: " .. (desc.value or "nil"))
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist for parse error")
      assert(string.find(desc.parsed_value.error, "invalid length") ~= nil, "error MUST contain 'invalid length', got: " .. tostring(desc.parsed_value.error))
      print("CCCD parse error test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01]  # Invalid: only 1 byte (should be 2)
                parse_error: "invalid length for client config: expected 2, got 1"
    expected_stdout: |
      CCCD parse error test passed

  - name: "Error: Parse Error in Extended Properties (Invalid Length)"
    # GOAL: Verify parse errors are correctly handled for Extended Properties
    #
    # TEST SCENARIO: Extended Properties with wrong length → verify error in parsed_value
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2900" then
        error("Expected Extended Properties (0x2900)")
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist")
      assert(string.find(desc.parsed_value.error, "invalid length") ~= nil, "error MUST contain 'invalid length', got: " .. tostring(desc.parsed_value.error))
      print("Extended Properties parse error test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2900"
                value: [0x03]  # Invalid: only 1 byte (should be 2)
                parse_error: "invalid length for extended properties: expected 2, got 1"
    expected_stdout: |
      Extended Properties parse error test passed

  - name: "Error: Parse Error in Presentation Format (Invalid Length)"
    # GOAL: Verify parse errors for Presentation Format descriptor
    #
    # TEST SCENARIO: Presentation Format with wrong length → verify error in parsed_value
    script: |
      local char = blim.characteristic("180f", "2a19")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2904" then
        error("Expected Presentation Format (0x2904)")
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist")
      assert(string.find(desc.parsed_value.error, "invalid length") ~= nil, "error MUST contain 'invalid length', got: " .. tostring(desc.parsed_value.error))
      print("Presentation Format parse error test passed")
    peripheral:
      - service: "180f"
        characteristics:
          - uuid: "2a19"
            descriptors:
              - uuid: "2904"
                value: [0x04, 0x00, 0x01]  # Invalid: only 3 bytes (should be 7)
                parse_error: "invalid length for presentation format: expected 7, got 3"
    expected_stdout: |
      Presentation Format parse error test passed

  - name: "Error: Invalid UTF-8 in User Description"
    # GOAL: Verify that invalid UTF-8 in User Description produces parse error
    #
    # TEST SCENARIO: User Description with invalid UTF-8 bytes → verify error in parsed_value
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2901" then
        error("Expected User Description (0x2901)")
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist for invalid UTF-8")
      assert(string.find(desc.parsed_value.error, "invalid UTF-8", 1, true) ~= nil, "error MUST contain 'invalid UTF-8', got: " .. tostring(desc.parsed_value.error))
      print("Invalid UTF-8 test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2901"
                value: [0xFF, 0xFE, 0xFD]  # Invalid UTF-8 sequence
                parse_error: "invalid UTF-8 in user description"
    expected_stdout: |
      Invalid UTF-8 test passed

# --- Read Errors ---

  - name: "Error: Descriptor Read Timeout"
    # GOAL: Verify that descriptor read timeouts are correctly represented
    #
    # TEST SCENARIO: Descriptor that times out during read → verify no value, parsed_value contains error
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2902" then
        error("Expected CCCD (0x2902)")
      end
      if desc.value then
        error("Expected no value field for timeout, got: " .. desc.value)
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist for timeout")
      assert(string.find(desc.parsed_value.error, "timeout") ~= nil, "error MUST contain 'timeout', got: " .. tostring(desc.parsed_value.error))
      print("Descriptor read timeout test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2902"
                read_error: "timeout"
    expected_stdout: |
      Descriptor read timeout test passed

  - name: "Error: Descriptor Read Failure"
    # GOAL: Verify that descriptor read errors are correctly represented
    #
    # TEST SCENARIO: Descriptor that fails to read → verify no value, parsed_value contains error
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2901" then
        error("Expected User Description (0x2901)")
      end
      if desc.value then
        error("Expected no value field for read error, got: " .. desc.value)
      end
      -- All assertions MUST execute unconditionally
      assert(desc.parsed_value ~= nil, "parsed_value MUST exist")
      assert(desc.parsed_value.error ~= nil, "parsed_value.error MUST exist")
      assert(string.find(desc.parsed_value.error, "read_error") ~= nil, "error MUST contain 'read_error', got: " .. tostring(desc.parsed_value.error))
      print("Descriptor read error test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2901"
                read_error: "permission denied"
    expected_stdout: |
      Descriptor read error test passed

# ===================================================================
# FIELD VALIDATION TESTS (3 tests)
# ===================================================================

  - name: "Descriptor Handle Field: Numeric Value"
    # GOAL: Verify that the descriptor handle field is present and contains numeric value
    #
    # TEST SCENARIO: Read descriptor from characteristic → verify handle field exists → verify it's a number
    script: |
      local char = blim.characteristic("180d", "2a37")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if not desc.handle then
        error("Expected handle field to exist")
      end
      if type(desc.handle) ~= "number" then
        error("Expected handle to be number, got: " .. type(desc.handle))
      end
      if desc.handle <= 0 then
        error("Expected handle to be positive, got: " .. tostring(desc.handle))
      end
      print("Descriptor handle field test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01, 0x00]
    expected_stdout: |
      Descriptor handle field test passed

  - name: "Descriptor Index Field: Sequential Numbering"
    # GOAL: Verify that descriptor index field is present and sequential across multiple descriptors
    #
    # TEST SCENARIO: Read characteristic with multiple descriptors → verify index field → verify sequential values starting from 0
    script: |
      local char = blim.characteristic("180d", "2a37")
      if #char.descriptors ~= 3 then
        error("Expected 3 descriptors, got: " .. #char.descriptors)
      end
      -- Verify each descriptor has index field with correct type
      for i = 1, #char.descriptors do
        local desc = char.descriptors[i]
        if not desc.index then
          error("Expected index field to exist for descriptor " .. i)
        end
        if type(desc.index) ~= "number" then
          error("Expected index to be number, got: " .. type(desc.index))
        end
        if desc.index < 0 then
          error("Expected index to be non-negative, got: " .. tostring(desc.index))
        end
      end
      -- Verify indices are sequential (after sorting by UUID: 2900, 2901, 2902)
      -- Index reflects order in BLE stack, not Lua array order
      print("Descriptor index field test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01, 0x00]
              - uuid: "2901"
                value: [0x48, 0x65, 0x61, 0x72, 0x74, 0x20, 0x52, 0x61, 0x74, 0x65]
              - uuid: "2900"
                value: [0x00, 0x00]
    expected_stdout: |
      Descriptor index field test passed

  - name: "Descriptor Handle Uniqueness: Multiple Descriptors"
    # GOAL: Verify that each descriptor has unique handle value
    #
    # TEST SCENARIO: Read characteristic with multiple descriptors → compare handle values → verify all handles are unique
    script: |
      local char = blim.characteristic("180d", "2a37")
      if #char.descriptors ~= 3 then
        error("Expected 3 descriptors, got: " .. #char.descriptors)
      end
      local handles = {}
      for i = 1, #char.descriptors do
        local desc = char.descriptors[i]
        local handle = desc.handle
        if handles[handle] then
          error("Duplicate handle found: " .. tostring(handle))
        end
        handles[handle] = true
      end
      print("Descriptor handle uniqueness test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01, 0x00]
              - uuid: "2901"
                value: [0x48, 0x65, 0x61, 0x72, 0x74, 0x20, 0x52, 0x61, 0x74, 0x65]
              - uuid: "2900"
                value: [0x00, 0x00]
    expected_stdout: |
      Descriptor handle uniqueness test passed

# ===================================================================
# COMPLEX DESCRIPTOR TESTS (4 tests)
# ===================================================================

  - name: "Multiple Descriptors: CCCD + User Description + Extended Properties"
    # GOAL: Verify multiple descriptors are all correctly exposed with values
    #
    # TEST SCENARIO: Characteristic with CCCD + User Description + Extended Properties → verify all three
    script: |
      local char = blim.characteristic("180d", "2a37")
      if #char.descriptors ~= 3 then
        error("Expected 3 descriptors, got: " .. #char.descriptors)
      end
      -- Descriptors are sorted alphabetically by UUID: 2900, 2901, 2902
      -- Check Extended Properties (first after sorting)
      local ext = char.descriptors[1]
      if ext.uuid ~= "2900" then
        error("Extended Properties UUID mismatch: expected 2900, got: " .. (ext.uuid or "nil"))
      end
      if ext.parsed_value.reliable_write ~= false then
        error("Extended Properties validation failed")
      end
      -- Check User Description (second after sorting)
      local desc = char.descriptors[2]
      if desc.uuid ~= "2901" then
        error("User Description UUID mismatch: expected 2901, got: " .. (desc.uuid or "nil"))
      end
      if desc.parsed_value ~= "Heart Rate" then
        error("User Description validation failed, got: " .. (desc.parsed_value or "nil"))
      end
      -- Check CCCD (third after sorting)
      local cccd = char.descriptors[3]
      if cccd.uuid ~= "2902" then
        error("CCCD UUID mismatch: expected 2902, got: " .. (cccd.uuid or "nil"))
      end
      -- All assertions MUST execute unconditionally
      assert(type(cccd.parsed_value) == "table", "CCCD parsed_value MUST be table, got type: " .. type(cccd.parsed_value))
      assert(cccd.parsed_value.error == nil, "CCCD parsed_value MUST NOT have error, got: " .. tostring(cccd.parsed_value.error))
      assert(cccd.parsed_value.notifications == true, "CCCD notifications MUST be true, got: " .. tostring(cccd.parsed_value.notifications))
      print("Multiple descriptors test passed")
    peripheral:
      - service: "180d"
        characteristics:
          - uuid: "2a37"
            descriptors:
              - uuid: "2902"
                value: [0x01, 0x00]  # Notifications enabled
              - uuid: "2901"
                value: [0x48, 0x65, 0x61, 0x72, 0x74, 0x20, 0x52, 0x61, 0x74, 0x65]  # "Heart Rate"
              - uuid: "2900"
                value: [0x00, 0x00]  # No extended properties
    expected_stdout: |
      Multiple descriptors test passed

  - name: "Empty Descriptors: Characteristic Without Descriptors"
    # GOAL: Verify characteristics without descriptors return empty array
    #
    # TEST SCENARIO: Characteristic with no descriptors → verify descriptors array is empty
    script: |
      local char = blim.characteristic("180f", "2a19")
      if #char.descriptors ~= 0 then
        error("Expected 0 descriptors, got: " .. #char.descriptors)
      end
      print("Empty descriptors test passed")
    peripheral:
      - service: "180f"
        characteristics:
          - uuid: "2a19"
            descriptors: []  # No descriptors
    expected_stdout: |
      Empty descriptors test passed

  - name: "Aggregate Format: Array of Descriptors"
    # GOAL: Verify Characteristic Aggregate Format descriptor contains an array of descriptor references
    #
    # TEST SCENARIO: Read Aggregate Format descriptor → verify parsed_value is table → verify contains descriptor objects with full structure
    script: |
      local char = blim.characteristic("1234", "5678")
      -- Descriptors sorted by UUID: 2904, 2904, 2905 → aggregate is at index 3
      local desc = char.descriptors[3]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2905" then
        error("Expected Aggregate Format (0x2905), got: " .. desc.uuid)
      end
      if desc.name ~= "Characteristic Aggregate Format" then
        error("Expected Aggregate Format name, got: " .. (desc.name or "nil"))
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if type(desc.parsed_value) ~= "table" then
        error("Expected parsed_value to be table, got: " .. type(desc.parsed_value))
      end
      if #desc.parsed_value ~= 2 then
        error("Expected 2 descriptors in aggregate, got: " .. #desc.parsed_value)
      end
      -- Verify first descriptor in aggregate has required fields
      local ref1 = desc.parsed_value[1]
      if not ref1.uuid then
        error("Expected uuid field in aggregated descriptor")
      end
      if not ref1.handle then
        error("Expected handle field in aggregated descriptor")
      end
      if not ref1.index then
        error("Expected index field in aggregated descriptor")
      end
      if type(ref1.handle) ~= "number" then
        error("Expected handle to be number")
      end
      if type(ref1.index) ~= "number" then
        error("Expected index to be number")
      end
      -- Verify second descriptor
      local ref2 = desc.parsed_value[2]
      if not ref2.uuid then
        error("Expected uuid field in second aggregated descriptor")
      end
      if ref1.handle == ref2.handle then
        error("Expected different handles for aggregated descriptors")
      end
      print("Aggregate Format test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2905"
                value: [0x00, 0x01, 0x01, 0x01]  # Handles 0x0100, 0x0101 (little-endian)
              - uuid: "2904"
                value: [0x04, 0x00, 0x01, 0x29, 0x01, 0x00, 0x00]
              - uuid: "2904"
                value: [0x04, 0x00, 0x01, 0x29, 0x01, 0x00, 0x00]
    expected_stdout: |
      Aggregate Format test passed

  - name: "Aggregate Format: Empty Array"
    # GOAL: Verify Aggregate Format with no references returns an empty array
    #
    # TEST SCENARIO: Read Aggregate Format with no descriptor references → verify parsed_value is empty table
    script: |
      local char = blim.characteristic("1234", "5678")
      local desc = char.descriptors[1]
      if not desc then
        error("Expected descriptor to exist")
      end
      if desc.uuid ~= "2905" then
        error("Expected Aggregate Format (0x2905)")
      end
      if not desc.parsed_value then
        error("Expected parsed_value table")
      end
      if type(desc.parsed_value) ~= "table" then
        error("Expected parsed_value to be table")
      end
      if #desc.parsed_value ~= 0 then
        error("Expected empty array, got length: " .. #desc.parsed_value)
      end
      print("Aggregate Format empty array test passed")
    peripheral:
      - service: "1234"
        characteristics:
          - uuid: "5678"
            descriptors:
              - uuid: "2905"
                value: []  # Empty aggregate (no references)
    expected_stdout: |
      Aggregate Format empty array test passed
