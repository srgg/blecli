// Code generated by bledb/gen; DO NOT EDIT.
//
// Data sources:
//   Services:        {{.ServiceURL}}
//   Characteristics: {{.CharacteristicURL}}
//   Descriptors:     {{.DescriptorURL}}
//   Vendors:         {{.VendorURL}}
//   BleakURL:        {{.BleakURL}}
//

package bledb

import "strings"

const DataVersion = {{printf "%q" .Timestamp}}

var (
	serviceMap        = map[string]string{
{{- range .ServiceEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	characteristicMap = map[string]string{
{{- range .CharacteristicEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	descriptorMap     = map[string]string{
{{- range .DescriptorEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	vendorMap         = map[string]string{
{{- range .VendorEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	unitMap         = map[string]string{
{{- range .UnitEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	bleakMap         = map[string]string{
{{- range .BleakEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
)

// LookupService returns the name for a given service UUID.
// If the UUID is not found, returns an empty string.
func LookupService(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := serviceMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupCharacteristic returns the name for a given characteristic UUID.
// If the UUID is not found, returns an empty string.
func LookupCharacteristic(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := characteristicMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupDescriptor returns the name for a given descriptor UUID.
// If the UUID is not found, returns an empty string.
func LookupDescriptor(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := descriptorMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupVendor returns the name for a given vendor ID.
// If the ID is not found, returns an empty string.
func LookupVendor(id string) string {
	normalized := NormalizeUUID(id)
	if name, ok := vendorMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupUnit returns the name of a Bluetooth measurement unit for the given UUID.
// If the UUID is not found in the unit map, returns an empty string.
func LookupUnit(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := unitMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// lookupInBleakUUIDs returns the name for a given UUID
// by checking the Bleak project database as a fallback.
//
// The Bleak project is MIT-licensed and contains both standard and
// proprietary/vendor-specific BLE UUIDs (e.g., Apple Nearby, ANCS).
//
// Only used if the UUID was not found in the primary Nordic database.
// Returns an empty string if the UUID is unknown.
func lookupInBleakUUIDs(normalizedId string) string {
	if name, ok := bleakMap[normalizedId]; ok {
		return name
	}
	return ""
}

// NormalizeUUID converts a UUID string to the internal BLE library format (lowercase, no dashes).
// Handles both standard UUID format (with dashes) and already normalized format (without dashes).
// Also strips 0x prefix if present (e.g., "0x2902" -> "2902").
// For full 128-bit UUIDs in Bluetooth SIG base format (0000xxxx-0000-1000-8000-00805f9b34fb),
// extracts the 16-bit short form (xxxx).
func NormalizeUUID(uuid string) string {
	// Strip 0x prefix if present
	uuid = strings.TrimPrefix(uuid, "0x")
	uuid = strings.TrimPrefix(uuid, "0X")

	// Remove dashes, braces and convert to lowercase
	uuid = strings.ReplaceAll(uuid, "-", "")
	uuid = strings.ReplaceAll(uuid, "{", "")
	uuid = strings.ReplaceAll(uuid, "}", "")
	uuid = strings.ToLower(uuid)

	// Check if this is a full 128-bit Bluetooth SIG base UUID (32 hex chars)
	// Format: 0000xxxx00001000800000805f9b34fb
	// Extract the 16-bit short form (xxxx) from positions 4-8
	if len(uuid) == 32 &&
		strings.HasPrefix(uuid, "0000") &&
		strings.HasSuffix(uuid, "00001000800000805f9b34fb") {
		return uuid[4:8]
	}

	return uuid
}

// NormalizeUUIDs normalizes a slice of UUID strings to internal format.
func NormalizeUUIDs(uuids []string) []string {
	normalized := make([]string, len(uuids))
	for i, uuid := range uuids {
		normalized[i] = NormalizeUUID(uuid)
	}
	return normalized
}