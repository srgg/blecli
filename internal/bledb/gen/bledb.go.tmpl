// Code generated by bledb/gen; DO NOT EDIT.
//
// Data sources:
//   Services:        {{.ServiceURL}}
//   Characteristics: {{.CharacteristicURL}}
//   Descriptors:     {{.DescriptorURL}}
//   Vendors:         {{.VendorURL}}
//   BleakURL:        {{.BleakURL}}
//

package bledb

import "strings"

const DataVersion = {{printf "%q" .Timestamp}}

var (
	serviceMap        = map[string]string{
{{- range .ServiceEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	characteristicMap = map[string]string{
{{- range .CharacteristicEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	descriptorMap     = map[string]string{
{{- range .DescriptorEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	vendorMap         = map[string]string{
{{- range .VendorEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	unitMap         = map[string]string{
{{- range .UnitEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
	bleakMap         = map[string]string{
{{- range .BleakEntries}}
		{{printf "%q" .UUID}}: {{printf "%q" .Name}},
{{- end}}
	}

	// Characteristic Presentation Format field lookups (static data from Bluetooth Core Spec)
	formatMap = map[uint8]string{
		0x01: "boolean",
		0x02: "uint2",
		0x03: "uint4",
		0x04: "uint8",
		0x05: "uint12",
		0x06: "uint16",
		0x07: "uint24",
		0x08: "uint32",
		0x09: "uint48",
		0x0A: "uint64",
		0x0B: "uint128",
		0x0C: "sint8",
		0x0D: "sint12",
		0x0E: "sint16",
		0x0F: "sint24",
		0x10: "sint32",
		0x11: "sint48",
		0x12: "sint64",
		0x13: "sint128",
		0x14: "float32",
		0x15: "float64",
		0x16: "sfloat16",
		0x17: "float16",
		0x18: "duint16",
		0x19: "utf8",
		0x1A: "utf16",
		0x1B: "struct",
	}

	namespaceMap = map[uint8]string{
		0x00: "Unknown",
		0x01: "Bluetooth SIG Assigned Numbers",
	}

	// Bluetooth SIG appearance values (GAP characteristic 0x2A01)
	// Encodes device category and subcategory for external appearance classification
	// Maps uint16 appearance code (e.g., 0x0040) to human-readable name
	appearanceCodeMap = map[uint16]string{
{{- range .AppearanceEntries}}
		0x{{.UUID}}: {{printf "%q" .Name}},
{{- end}}
	}
)

// LookupService returns the name for a given service UUID.
// If the UUID is not found, returns an empty string.
func LookupService(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := serviceMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupCharacteristic returns the name for a given characteristic UUID.
// If the UUID is not found, returns an empty string.
func LookupCharacteristic(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := characteristicMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupDescriptor returns the name for a given descriptor UUID.
// If the UUID is not found, returns an empty string.
func LookupDescriptor(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := descriptorMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupVendor returns the name for a given vendor ID.
// If the ID is not found, returns an empty string.
func LookupVendor(id string) string {
	normalized := NormalizeUUID(id)
	if name, ok := vendorMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupUnit returns the name of a Bluetooth measurement unit for the given UUID.
// If the UUID is not found in the unit map, returns an empty string.
func LookupUnit(uuid string) string {
	normalized := NormalizeUUID(uuid)
	if name, ok := unitMap[normalized]; ok {
		return name
	}
	return lookupInBleakUUIDs(normalized)
}

// LookupFormat returns the human-readable name for a Characteristic Presentation Format type code.
// Used with the Format field in PresentationFormat descriptor (0x2904).
// If the format code is not recognized, returns an empty string.
func LookupFormat(formatCode uint8) string {
	if name, ok := formatMap[formatCode]; ok {
		return name
	}
	return ""
}

// LookupNamespace returns the name of a descriptor namespace.
// Used with the Namespace field in PresentationFormat descriptor (0x2904).
// If the namespace code is not recognized, returns an empty string.
func LookupNamespace(namespaceCode uint8) string {
	if name, ok := namespaceMap[namespaceCode]; ok {
		return name
	}
	return ""
}

// LookupAppearanceCode returns the human-readable name for a GAP Appearance code.
// The Appearance characteristic (0x2A01) encodes device type as a 16-bit value:
// upper 10 bits = category, lower 6 bits = subcategory.
// Accepts appearance code as uint16 (e.g., 0x0040 for Generic Phone).
// If the appearance code is not recognized, returns an empty string.
func LookupAppearanceCode(code uint16) string {
	if name, ok := appearanceCodeMap[code]; ok {
		return name
	}
	return ""
}

// lookupInBleakUUIDs returns the name for a given UUID
// by checking the Bleak project database as a fallback.
//
// The Bleak project is MIT-licensed and contains both standard and
// proprietary/vendor-specific BLE UUIDs (e.g., Apple Nearby, ANCS).
//
// Only used if the UUID was not found in the primary Nordic database.
// Returns an empty string if the UUID is unknown.
func lookupInBleakUUIDs(normalizedId string) string {
	if name, ok := bleakMap[normalizedId]; ok {
		return name
	}
	return ""
}

// NormalizeUUID converts a UUID string to the internal BLE library format (lowercase, no dashes).
// Handles both standard UUID format (with dashes) and already normalized format (without dashes).
// Also strips 0x prefix if present (e.g., "0x2902" -> "2902").
// For full 128-bit UUIDs in Bluetooth SIG base format (0000xxxx-0000-1000-8000-00805f9b34fb),
// extracts the 16-bit short form (xxxx).
func NormalizeUUID(uuid string) string {
	// Strip 0x prefix if present
	uuid = strings.TrimPrefix(uuid, "0x")
	uuid = strings.TrimPrefix(uuid, "0X")

	// Remove dashes, braces and convert to lowercase
	uuid = strings.ReplaceAll(uuid, "-", "")
	uuid = strings.ReplaceAll(uuid, "{", "")
	uuid = strings.ReplaceAll(uuid, "}", "")
	uuid = strings.ToLower(uuid)

	// Check if this is a full 128-bit Bluetooth SIG base UUID (32 hex chars)
	// Format: 0000xxxx00001000800000805f9b34fb
	// Extract the 16-bit short form (xxxx) from positions 4-8
	if len(uuid) == 32 &&
		strings.HasPrefix(uuid, "0000") &&
		strings.HasSuffix(uuid, "00001000800000805f9b34fb") {
		return uuid[4:8]
	}

	return uuid
}

// NormalizeUUIDs normalizes a slice of UUID strings to internal format.
func NormalizeUUIDs(uuids []string) []string {
	normalized := make([]string, len(uuids))
	for i, uuid := range uuids {
		normalized[i] = NormalizeUUID(uuid)
	}
	return normalized
}