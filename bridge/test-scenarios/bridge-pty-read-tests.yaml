test_cases:
  - name: "PTY Read: Basic Read Operation"
    # GOAL: Verify pty_read() reads data from PTY master (written to slave by test)
    #
    # TEST SCENARIO: Test writes to slave → Lua reads via pty_read()
    steps:
      - pty_slave_write: "hello from slave"
        lua: |
          blim.sleep(50)  -- Wait for data to be available
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(data == "hello from slave", "Expected 'hello from slave', got '" .. data .. "'")

  - name: "PTY Read: Non-Blocking Empty Read"
    # GOAL: Verify pty_read() returns an empty string when no data is available
    #
    # TEST SCENARIO: Don't write anything → pty_read() returns ("", nil)
    steps:
      - lua: |
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed when no data, got error: " .. tostring(err))
          assert(data == "", "Expected empty string, got '" .. data .. "'")

  - name: "PTY Read: Custom Buffer Size"
    # GOAL: Verify pty_read(max_bytes) respects buffer size limit
    #
    # TEST SCENARIO: Write 128 bytes → pty_read(64) returns only 64 bytes
    steps:
      - pty_slave_write: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local expected = string.rep("B", 64)
          local data, err = blim.bridge.pty_read(64)
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(#data == 64, "Expected 64 bytes, got " .. #data)
          assert(data == expected, "Data mismatch: expected all B's")

  - name: "PTY Read: Oversized Buffer Request"
    # GOAL: Verify pty_read() returns only available data when buffer size exceeds available bytes
    #       (separate from Custom Buffer Size which tests buffer size < available data)
    #
    # TEST SCENARIO: Write 32 bytes → pty_read(100) returns only 32 bytes
    steps:
      - pty_slave_write: "ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local expected = string.rep("Z", 32)
          local data, err = blim.bridge.pty_read(100)
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(#data == 32, "Expected 32 bytes (all available), got " .. #data)
          assert(data == expected, "Data mismatch: expected all Z's")

  - name: "PTY Read: Binary Data"
    # GOAL: Verify pty_read() correctly handles binary data
    #
    # TEST SCENARIO: Write binary bytes to slave → Lua reads exact binary data
    steps:
      - pty_slave_write: [0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD]
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(#data == 6, "Expected 6 bytes, got " .. #data)
          -- Verify binary values
          assert(string.byte(data, 1) == 0x01, "Byte 1 MUST be 0x01")
          assert(string.byte(data, 2) == 0x02, "Byte 2 MUST be 0x02")
          assert(string.byte(data, 3) == 0x03, "Byte 3 MUST be 0x03")
          assert(string.byte(data, 4) == 0xFF, "Byte 4 MUST be 0xFF")
          assert(string.byte(data, 5) == 0xFE, "Byte 5 MUST be 0xFE")
          assert(string.byte(data, 6) == 0xFD, "Byte 6 MUST be 0xFD")

  - name: "PTY Read: Invalid Buffer Size"
    # GOAL: Verify pty_read() returns error for invalid buffer size
    #
    # TEST SCENARIO: Call pty_read(-1) and pty_read(0) → both return (nil, error)
    steps:
      - lua: |
          -- Test negative buffer size
          local data, err = blim.bridge.pty_read(-1)
          assert(data == nil, "pty_read(-1) MUST return nil")
          assert(err ~= nil, "pty_read(-1) MUST return error")
          assert(string.find(tostring(err), "positive integer"), "Error message MUST mention 'positive integer', got: " .. tostring(err))

          -- Test zero buffer size
          local data2, err2 = blim.bridge.pty_read(0)
          assert(data2 == nil, "pty_read(0) MUST return nil")
          assert(err2 ~= nil, "pty_read(0) MUST return error")
          assert(string.find(tostring(err2), "positive integer"), "Error message MUST mention 'positive integer', got: " .. tostring(err2))

  - name: "PTY Read: Large Data Block"
    # GOAL: Verify pty_read() handles moderately-sized data blocks without blocking
    #       (regression test for PTY buffer overflow - 128 bytes is safe, 4KB+ blocks)
    #
    # TEST SCENARIO: Write 128 bytes to slave → pty_read() returns all 128 bytes
    steps:
      - pty_slave_write: "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
        lua: |
          blim.sleep(200)  -- Wait for data to be available (larger data needs more time)
          local expected = string.rep("X", 128)
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(#data == 128, "Expected 128 bytes, got " .. #data)
          assert(data == expected, "Data mismatch: expected all X's")

  - name: "PTY Write-Read Roundtrip"
    # GOAL: Verify complete bidirectional PTY communication
    #
    # TEST SCENARIO: Lua writes "ping" → test reads → test writes "pong" → Lua reads
    steps:
      - lua: |
          local bytes, err = blim.bridge.pty_write("ping")
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
        expected_pty_slave_read: "ping"
      - pty_slave_write: "pong"
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(data == "pong", "Expected 'pong', got '" .. data .. "'")

  - name: "PTY Read: Multiple Sequential Reads"
    # GOAL: Verify multiple pty_read() calls in sequence
    #
    # TEST SCENARIO: Slave writes "Hello", then "World" → Lua reads both in order
    steps:
      - pty_slave_write: "Hello"
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(data == "Hello", "Expected 'Hello', got '" .. data .. "'")
      - pty_slave_write: "World"
        lua: |
          blim.sleep(100)  -- Wait for data to be available
          local data, err = blim.bridge.pty_read()
          assert(err == nil, "pty_read MUST succeed, got error: " .. tostring(err))
          assert(data == "World", "Expected 'World', got '" .. data .. "'")