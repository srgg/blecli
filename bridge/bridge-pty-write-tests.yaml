test_cases:
  - name: "PTY Write: Basic Write Operation"
    # GOAL: Verify pty_write() writes data to PTY master that appears on slave
    #
    # TEST SCENARIO: Lua calls blim.bridge.pty_write("test data") → test reads from slave
    steps:
      - lua: |
          local bytes, err = blim.bridge.pty_write("test data")
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 9, "Expected 9 bytes written, got " .. tostring(bytes))
        expected_pty_slave_read: "test data"

  - name: "PTY Write: Binary Data"
    # GOAL: Verify pty_write() correctly handles binary data with null bytes
    #
    # TEST SCENARIO: Lua writes binary string with 0x00, 0x01, 0x02, 0xFF → all bytes preserved
    steps:
      - lua: |
          local data = "test\x00\x01\x02\xFF"
          local bytes, err = blim.bridge.pty_write(data)
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 8, "Expected 8 bytes written, got " .. tostring(bytes))
        expected_pty_slave_read: [0x74, 0x65, 0x73, 0x74, 0x00, 0x01, 0x02, 0xFF]  # "test" + binary

  - name: "PTY Write: Large Data Block"
    # GOAL: Verify pty_write() handles moderately-sized data blocks without blocking
    #       (regression test for PTY buffer overflow - 128 bytes is safe, 4KB+ blocks)
    #
    # TEST SCENARIO: Lua writes 128 bytes → all bytes correctly written to slave
    steps:
      - lua: |
          local data = string.rep("A", 128)
          local bytes, err = blim.bridge.pty_write(data)
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 128, "Expected 128 bytes written, got " .. tostring(bytes))
        expected_pty_slave_read: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

  - name: "PTY Write: Invalid Argument Type"
    # GOAL: Verify pty_write() returns error for non-string arguments
    #
    # TEST SCENARIO: Call pty_write(123) → returns (nil, error)
    steps:
      - lua: |
          local bytes, err = blim.bridge.pty_write(123)
          assert(bytes == nil, "pty_write(123) MUST return nil for invalid argument")
          assert(err ~= nil, "pty_write(123) MUST return error for invalid argument")
          assert(string.find(tostring(err), "expects a string"), "Error message MUST mention 'expects a string', got: " .. tostring(err))

  - name: "PTY Write: Multiple Sequential Writes"
    # GOAL: Verify multiple pty_write() calls in sequence
    #
    # TEST SCENARIO: Write "Hello", then " ", then "World" → all data arrives in order
    steps:
      - lua: |
          local bytes, err = blim.bridge.pty_write("Hello")
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 5, "Expected 5 bytes written, got " .. tostring(bytes))
        expected_pty_slave_read: "Hello"
      - lua: |
          local bytes, err = blim.bridge.pty_write(" ")
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 1, "Expected 1 byte written, got " .. tostring(bytes))
        expected_pty_slave_read: " "
      - lua: |
          local bytes, err = blim.bridge.pty_write("World")
          assert(err == nil, "pty_write MUST succeed, got error: " .. tostring(err))
          assert(bytes == 5, "Expected 5 bytes written, got " .. tostring(bytes))
        expected_pty_slave_read: "World"

  - name: "PTY Write: Empty String"
    # GOAL: Verify pty_write() handles empty string gracefully
    #
    # TEST SCENARIO: Write empty string → returns 0 bytes written, no error
    steps:
      - lua: |
          local bytes, err = blim.bridge.pty_write("")
          assert(err == nil, "pty_write MUST succeed for empty string, got error: " .. tostring(err))
          assert(bytes == 0, "Expected 0 bytes written, got " .. tostring(bytes))